:imagesdir: ../images
= Kubernetes Architecture

Kubernetes at it's core is a database (etcd) connected to "watchers" and "controllers".  The database contains the user's desired state while the "watchers" look for changes to the desired state and determine what changes the "controllers" need to make to the nodes.  

image::kubeArch.png[Kubernetes Architecture]

== Nodes

A node is a worker machine in Kubernetes, previously known as a minion. A node may be a VM or physical machine, depending on the cluster. Each node contains the services necessary to run pods and is managed by the master components. The services on a node include the container runtime, kubelet and kube-proxy.

=== Master Nodes

A master node controls the allocation of workloads across the cluster's nodes.  The master node is the apiserver for the whole cluster, communicating with both the worker nodes and database to ensure the desired state from the user is fulfilled.  There are two ways the master node can communicate with the rest of the cluster. The first is from the apiserver to the kubelet process which runs on each node in the cluster. The second is from the apiserver to any node, pod, or service through the apiserver’s proxy functionality.

.Read More
NOTE: Cluster Communication: 
      https://kubernetes.io/docs/concepts/architecture/master-node-communication/[Here , window="_blank"]

== Node Management

Nodes, unlike pods or services, are not created by Kubernetes.  Nodes are created by the cloud platforms in which they are being hosted or it created from a pool of either physical or vitual machines.  So when kubernetes needs to create and validate an object that the node.  These node objects are interacted with by three different components: Node Controller, Kubelet, and Kubectl.

=== Node Controller

A node controller is the master component that manages a node through it's lifecycle with three main roles.  The first is assigning a CIDR block to the node when it is registered. Next, is keeping the node controller’s internal list of nodes up to date with the cloud provider’s list of available machines. Finally, is monitoring the node's health.  The node controller is responsible for updating the NodeReady condition of NodeStatus to ConditionUnknown when a node becomes unreachable (i.e. the node controller stops receiving heartbeats for some reason, e.g. due to the node being down), and then later evicting all the pods from the node (using graceful termination) if the node continues to be unreachable.

.More Details
NOTE: Node Management:
    https://kubernetes.io/docs/concepts/architecture/nodes/#management[Here, window="_blank"]

== Try It Out

The link below will take you to Katacoda to walk you through launching a single node cluster.  You will use *kubectl* to create a *deployment* and expose it's ports for HTTP communication.

.Walkthrough
NOTE: Node Deployment: 
      https://www.katacoda.com/courses/kubernetes/launch-single-node-cluster[Katacoda , window="_blank"]
